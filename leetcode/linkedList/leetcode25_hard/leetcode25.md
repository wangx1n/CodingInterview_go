# leetcode25

1. 分为K组，每一组都为翻转链表。翻转后需要接回原表，所以要记录翻转后的链表的首尾。其中头链接上一组链表的尾，尾接下一个链表的头。
2. 所以，在翻转每一组之前，要记录上一组链表的尾`pre`，和下一组链表的头`tail.Next = nex`。其中，在翻转第一组时，**创造一个`hair`节点，充当`pre`**。翻转最后一组链表时，`nex`为空，所以最后一组链表翻转后的尾，连接`nex`，所以最后一组链表的结尾为空。
3. 在翻转完每一组后，移动`pre`到当前组的`tail`，移动`head`到`nex`。



值得注意的点：

1. 迭代以`head!=nil`为条件，可以对传入的链表的`head`进行操作。
2. 翻转每一组链表的时候，`head`和`tail`的位置是一直不变的，返回的时候将`head`和`tail`反过来返回就可以了。
3. 翻转每一组链表的时候，判断条件是`pre := tail.Next pre!=tail`。这里的理解方式为，那道翻转链表的题目，`pre`是自己创造的，是`&ListNode{}`。在k个一组翻转链表时，`pre`不需要自己创造，因为当前链表翻转过后，马上需要链接到下一个链表上，下一个链表的头就是`pre`，即`pre := tail.Next`。由于当前链表的下一个链表是不为空的，所以不能以`head!=nil`作为判断条件。判断当前节点是否是当前链表的最后一个节点，就可以用`pre!=tail`，**这是因为，下一个链表的`pre`就应当为`tail`，当`pre`到达`tail`的时候，翻转就停了。**